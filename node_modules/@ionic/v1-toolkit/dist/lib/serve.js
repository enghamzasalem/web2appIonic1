"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const chalk_1 = require("chalk");
const path = require("path");
const dev_server_1 = require("./dev-server");
const gulp_1 = require("./gulp");
const log_1 = require("./log");
exports.WATCH_PATTERNS = [
    'scss/**/*',
    'www/**/*',
    '!www/lib/**/*',
    '!www/**/*.map',
];
function proxyConfigToMiddlewareConfig(proxy) {
    const config = {
        pathRewrite: { [proxy.path]: '' },
        target: proxy.proxyUrl,
    };
    if (proxy.proxyNoAgent) {
        config.agent = false; // TODO: type issue
    }
    if (proxy.rejectUnauthorized === false) {
        config.secure = false;
    }
    return config;
}
exports.proxyConfigToMiddlewareConfig = proxyConfigToMiddlewareConfig;
const DEFAULT_PROXY_CONFIG = {
    changeOrigin: true,
    logLevel: 'warn',
    ws: true,
};
function runServer(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let reloadfn;
        if (options.livereload) {
            reloadfn = yield dev_server_1.createLiveReloadServer({ host: options.host, port: options.livereloadPort, wwwDir: options.wwwDir });
        }
        yield createHttpServer(options);
        const chokidar = yield Promise.resolve().then(() => require('chokidar'));
        const watcher = chokidar.watch(options.watchPatterns);
        watcher.on('change', (filePath) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            process.stdout.write(`${log_1.timestamp()} ${chalk_1.default.bold(filePath)} changed\n`);
            if (path.extname(filePath) === '.scss') {
                yield gulp_1.runTask('sass');
            }
            else {
                if (reloadfn) {
                    reloadfn([filePath]);
                }
            }
        }));
        watcher.on('error', (err) => {
            process.stderr.write(`${log_1.timestamp()} Error in file watcher: ${err.stack ? err.stack : err}\n`);
        });
        return options;
    });
}
exports.runServer = runServer;
/**
 * Create HTTP server
 */
function createHttpServer(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const express = yield Promise.resolve().then(() => require('express'));
        const app = express();
        /**
         * http responder for /index.html base entrypoint
         */
        const serveIndex = (req, res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            // respond with the index.html file
            const indexFileName = path.join(options.wwwDir, 'index.html');
            let indexHtml = yield utils_fs_1.readFile(indexFileName, { encoding: 'utf8' });
            indexHtml = dev_server_1.injectDevServerScript(indexHtml);
            if (options.livereload) {
                indexHtml = dev_server_1.injectLiveReloadScript(indexHtml, options.livereloadPort);
            }
            res.set('Content-Type', 'text/html');
            res.send(indexHtml);
        });
        const serveCordovaPlatformResource = (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options.engine !== 'cordova' || !options.platform) {
                return next();
            }
            const resourcePath = path.resolve('platforms', options.platform, 'platform_www');
            if (yield utils_fs_1.pathExists(path.join(resourcePath, req.url))) {
                res.sendFile(req.url, { root: resourcePath });
            }
            else {
                next();
            }
        });
        app.get('/', serveIndex);
        app.use('/', (req, res, next) => {
            res.header('Access-Control-Allow-Origin', '*');
            next();
        });
        app.use('/', express.static(options.wwwDir));
        // Cordova
        app.get('/cordova.js', serveCordovaPlatformResource, serveMockCordovaJS);
        app.get('/cordova_plugins.js', serveCordovaPlatformResource);
        app.get('/plugins/*', serveCordovaPlatformResource);
        const livereloadUrl = `http://localhost:${options.livereloadPort}`;
        const pathPrefix = `/${dev_server_1.DEV_SERVER_PREFIX}/tiny-lr`;
        yield attachProxy(app, Object.assign({}, DEFAULT_PROXY_CONFIG, { mount: pathPrefix, target: livereloadUrl, pathRewrite: { [pathPrefix]: '' } }));
        for (const proxy of options.proxies) {
            yield attachProxy(app, Object.assign({}, DEFAULT_PROXY_CONFIG, proxy));
            process.stdout.write(`${log_1.timestamp()} Proxy created ${chalk_1.default.bold(proxy.mount)} => ${proxy.target ? chalk_1.default.bold(proxy.target) : '<no target>'}\n`);
        }
        app.get(`/${dev_server_1.DEV_SERVER_PREFIX}/dev-server.js`, yield dev_server_1.createDevServerHandler(options));
        const wss = yield dev_server_1.createDevLoggerServer(options.host, options.devPort);
        return new Promise((resolve, reject) => {
            const httpserv = app.listen(options.port, options.host);
            wss.on('error', err => {
                reject(err);
            });
            httpserv.on('error', err => {
                reject(err);
            });
            httpserv.on('listening', () => {
                resolve(app);
            });
        });
    });
}
function attachProxy(app, config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const proxyMiddleware = yield Promise.resolve().then(() => require('http-proxy-middleware'));
        app.use(config.mount, proxyMiddleware(config.mount, config));
    });
}
function serveMockCordovaJS(req, res) {
    res.set('Content-Type', 'application/javascript');
    res.send('// mock cordova file during development');
}
